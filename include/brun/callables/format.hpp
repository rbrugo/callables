/**
 * @author      : rbrugo (brugo.riccardo@gmail.com)
 * @created     : Tuesday Feb 11, 2025 19:22:56 CET
 * @description : utilities to convert stuff to string
 * @license     :
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * */

#ifndef CB_FORMAT_HPP
#define CB_FORMAT_HPP

#include <iterator>
#include <ranges>
#include "detail/_config_begin.hpp"

#if CB_HAS_FORMAT == 1
#include <format>
#endif
#if CB_HAS_EXPECTED == 1
#include <expected>
#endif

namespace callables
{

// to_string
// format
// ston (string to number)

#if CB_HAS_FORMAT == 1
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .................................TO_STRING.................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct to_string_t
{
    template <typename T>
    static constexpr auto operator()(T const & t) -> std::string
    { return std::format("{}", t); }

};

constexpr inline to_string_t to_string;

// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ...................................FORMAT................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
template <typename T, std::size_t Size>
struct fixed_string
{
    using size_type = decltype(Size);

    constexpr fixed_string(T const * str) {
        for (size_type  i = {}; i < Size; ++i) { data[i] = str[i]; }
        data[Size] = T();
    }
    [[nodiscard]] constexpr auto operator<=>(const fixed_string&) const = default;
    [[nodiscard]] constexpr operator std::string_view() const { return {std::data(data), Size}; }
    [[nodiscard]] constexpr auto size() const { return Size; }

    T data[Size + 1u];
};
template<class T, std::size_t Capacity, std::size_t Size = Capacity - 1>
fixed_string(const T (&str)[Capacity]) -> fixed_string<T, Size>;

template <fixed_string Fmt>
struct format_t
{
    template <typename T>
    static constexpr auto operator()(T && t) {
        return std::format(Fmt, std::forward<T>(t));
    }
};

template <fixed_string Fmt>
constexpr inline auto format = format_t<Fmt>{};
#endif  // CB_HAS_FORMAT

// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ....................................STON.................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
namespace policy
{
struct use_exception
{
    template <typename T>
    using result_t = T;

    template <typename T>
    CB_STATIC constexpr auto make_result(T && t) CB_CONST noexcept -> result_t<T>
    {
        return CB_FWD(t);
    }

    template <typename T>
    [[noreturn]] CB_STATIC constexpr auto make_failure(std::errc error) CB_CONST -> result_t<T>
    {
        throw std::system_error{std::make_error_code(error)};
    }
};
struct use_pair_with_errc {
    template <typename T> using result_t = std::pair<T, std::errc>;
    template <typename T>
    CB_STATIC constexpr auto make_result(T && t) CB_CONST noexcept(noexcept(result_t{CB_FWD(t), std::errc()}))
        -> result_t<T>
    {
        return result_t{CB_FWD(t), std::errc()};
    }

    template <typename T>
    CB_STATIC constexpr auto make_failure(std::errc error) CB_CONST noexcept(noexcept(T()))
        -> result_t<T>
    {
        return result_t{T(), error};
    }
};
struct use_optional {
    template <typename T> using result_t = std::optional<T>;
    template <typename T>
    CB_STATIC constexpr auto make_result(T && t) CB_CONST noexcept(noexcept(result_t{CB_FWD(t)}))
        -> result_t<T>
    {
        return std::optional{CB_FWD(t)};
    }
    template <typename T>
    CB_STATIC constexpr auto make_failure(std::errc error) CB_CONST noexcept
        -> result_t<T>
    {
        return std::nullopt;
    }
};
struct use_expected {
#if CB_HAS_EXPECTED == 1
    template <typename T> using result_t = std::expected<T, std::errc>;
    template <typename T>
    CB_STATIC constexpr auto make_result(T && t) CB_CONST noexcept(noexcept(result_t{CB_FWD(t)}))
        -> result_t<T>
    {
        return std::expected<T, std::errc>{CB_FWD(t)};
    }
    template <typename T>
    CB_STATIC constexpr auto make_failure(std::errc error) CB_CONST noexcept
        -> result_t<T>
    {
        return std::unexpected<std::errc>(error);
    }
#else
    static_assert(false, "can't use `std::expected` with this compiler configuration");
#endif
};
}  // namespace policy

template <typename Num, typename ResultPolicy, int Base>
struct ston_fn
{
    static_assert(Base >= 2 and Base <= 32, "the base must be included within [2,32]");

    static constexpr auto use_exception = std::same_as<ResultPolicy, policy::use_exception>;

    template <std::contiguous_iterator It, std::sentinel_for<It> Sent>
        requires (std::same_as<std::iter_value_t<It>, char>)
    [[nodiscard]]
    CB_STATIC constexpr
    auto operator()(It && begin, Sent && end) noexcept(not use_exception)
    {
        auto result = Num{};
        auto [ptr, ec] = std::from_chars(std::to_address(begin), std::to_address(end), result, Base);
        if (ec == std::errc()) {
            return ResultPolicy::make_result(result);
        }
        return ResultPolicy::template make_failure<Num>(ec);
    }

    template <std::ranges::contiguous_range Rng>
        requires (std::same_as<std::ranges::range_value_t<Rng>, char>)
    [[nodiscard]]
    CB_STATIC constexpr auto operator()(Rng && rng) noexcept(not use_exception)
    {
        return operator()(std::ranges::begin(rng), std::ranges::end(rng));
    }
};

template <typename Num, typename Policy = policy::use_exception, int Base = 10>
constexpr inline ston_fn<Num, Policy, Base> ston;

} // namespace callables

#include "detail/_config_end.hpp"  // IWYU pragma: export
#endif /* CB_FORMAT_HPP */
