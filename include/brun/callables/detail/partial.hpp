/**
 * @author      : Riccardo Brugo (brugo.riccardo@gmail.com)
 * @created     : Tuesday Sep 19, 2023 16:01:09 CEST
 * @description : implementation details regarding partial application
 * @license     :
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * */

#ifndef CB_DETAIL_PARTIAL_HPP
#define CB_DETAIL_PARTIAL_HPP

#include <concepts>
#include <utility>
#include "_config_begin.hpp"

namespace callables
{

#define CB_FWD(x) static_cast<decltype(x) &&>(x)
#define CB_FWD_LIKE(tp, x) detail::forward_like<decltype(tp)>(x)

namespace detail
{
template <typename T>
constexpr inline auto tuple_size = std::tuple_size_v<std::remove_cvref_t<T>>;

// From https://en.cppreference.com/w/cpp/utility/forward_like
template<class T, class U>
constexpr auto forward_like(U&& x) noexcept -> auto &&
{
    constexpr bool is_adding_const = std::is_const_v<std::remove_reference_t<T>>;
    if constexpr (std::is_lvalue_reference_v<T &&>) {
        if constexpr (is_adding_const) {
            return std::as_const(x);
        } else {
            return static_cast<U&>(x);
        }
    } else {
        if constexpr (is_adding_const) {
            return std::move(std::as_const(x));
        } else {
            return std::move(x);
        }
    }
}
}  // namespace detail

template <typename Fn, typename T>
struct partial
{
private:
    T _t;

public:
    template <typename U> requires std::constructible_from<T, U>
    constexpr explicit partial(U && u) : _t{CB_FWD(u)} {}

    template <typename ...U> requires std::regular_invocable<Fn, T, U...>
    [[nodiscard]] constexpr
    auto operator()(U &&... u) const noexcept(noexcept(Fn{}(_t, CB_FWD(u)...))) -> decltype(auto)
    { return Fn{}(_t, CB_FWD(u)...); }
};

template <typename Fn, typename T>
struct right_partial
{
private:
    T _t;

public:
    template <typename U> requires std::constructible_from<T, U>
    constexpr explicit right_partial(U && u) : _t{CB_FWD(u)} {}
    template <typename ...U> requires std::regular_invocable<Fn, U..., T>
    [[nodiscard]] constexpr
    auto operator()(U &&... u) const noexcept(noexcept(Fn{}(CB_FWD(u)..., _t))) -> decltype(auto)
    { return Fn{}(CB_FWD(u)..., _t); }
};

struct binary_fn
{
    using is_transparent = void;

    template <typename Self, typename T>
    [[nodiscard]] constexpr
    auto left(this Self const &, T && t) noexcept(noexcept(partial<Self, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}))
    {
        return partial<Self, std::unwrap_ref_decay_t<T>>{CB_FWD(t)};
    }

    template <typename Self, typename T>
    [[nodiscard]] constexpr
    auto right(this Self const &, T && t) noexcept(noexcept(right_partial<Self, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}))
    { return right_partial<Self, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}; }

    template <typename Self, typename T>
    [[nodiscard]] constexpr
    auto operator()(this Self const & self, T && t) noexcept(noexcept(self.left(CB_FWD(t))))
    { return self.left(CB_FWD(t)); }
};

template <typename Base>
struct compare_tuple_fn
{
    template <typename Tuple>
        requires (detail::tuple_size<Tuple> > 1)
    [[nodiscard]] constexpr static
    auto operator()(Tuple && p) -> decltype(auto)
    {
        return [p=CB_FWD(p)]<std::size_t ...I>(std::index_sequence<I...>) {
            return (Base{}(CB_FWD_LIKE(p, get<I>(p)), CB_FWD_LIKE(p, get<I + 1>(p))) and ...);
        }(std::make_index_sequence<detail::tuple_size<Tuple> - 1>{});
    }
};

template <typename Base>
struct compare_operator : public binary_fn
{
    using binary_fn::right;
    template <typename Self, typename T>
    [[nodiscard]] constexpr
    auto operator()(this Self const & self, T && t) noexcept(noexcept(self.right(CB_FWD(t))))
    { return self.right(CB_FWD(t)); }
    [[no_unique_address]] compare_tuple_fn<Base> tuple;
};

template <typename Base>
struct recursive_tuple_fn
{
    template <typename Tuple>
        requires (detail::tuple_size<Tuple> > 0)
    [[nodiscard]] constexpr static
    auto operator()(Tuple && p) -> decltype(auto)
    {
        return [p=CB_FWD(p)]<std::size_t ...I>(std::index_sequence<I...>) {
            return (Base{}(CB_FWD_LIKE(p, get<I>(p))...));
        }(std::make_index_sequence<detail::tuple_size<Tuple>>{});
    }
};

template <typename Base>
struct applicable_on_tuples
{
    [[no_unique_address]] recursive_tuple_fn<Base> tuple;
};

#undef CB_FWD_LIKE
#undef CB_FWD
} // namespace callables

#include "_config_end.hpp"  // IWYU pragma: export
#endif /* CB_DETAIL_PARTIAL_HPP */
