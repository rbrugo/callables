/**
 * @author      : Riccardo Brugo (brugo.riccardo@gmail.com)
 * @file        : partial
 * @created     : Tuesday Sep 19, 2023 16:01:09 CEST
 * @description : implementation details regarding partial application
 * @license     :
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * */

#ifndef CB_DETAIL_PARTIAL_HPP
#define CB_DETAIL_PARTIAL_HPP

#include <concepts>
#include <utility>
#include "config.hpp"

namespace callables
{

#define CB_FWD(x) static_cast<decltype(x) &&>(x)
#define CB_FWD_LIKE(tp, x) detail::forward_like<decltype(tp)>(x)

namespace detail
{
template <typename T>
constexpr inline auto tuple_size = std::tuple_size_v<std::remove_cvref_t<T>>;

// From https://en.cppreference.com/w/cpp/utility/forward_like
template<class T, class U>
constexpr auto forward_like(U&& x) noexcept -> auto &&
{
    constexpr bool is_adding_const = std::is_const_v<std::remove_reference_t<T>>;
    if constexpr (std::is_lvalue_reference_v<T &&>) {
        if constexpr (is_adding_const) {
            return std::as_const(x);
        } else {
            return static_cast<U&>(x);
        }
    } else {
        if constexpr (is_adding_const) {
            return std::move(std::as_const(x));
        } else {
            return std::move(x);
        }
    }
}
}  // namespace detail

template <typename Fn, typename T>
struct partial
{
private:
    T _t;

public:
    template <typename U> requires std::constructible_from<T, U>
    constexpr explicit partial(U && u) : _t{CB_FWD(u)} {}

    template <typename ...U> requires std::regular_invocable<Fn, T, U...>
    [[nodiscard]] constexpr
    auto operator()(U &&... u) const noexcept(noexcept(Fn{}(_t, CB_FWD(u)...))) -> decltype(auto)
    { return Fn{}(_t, CB_FWD(u)...); }
};

template <typename Fn, typename T>
struct right_partial
{
private:
    T _t;

public:
    template <typename U> requires std::constructible_from<T, U>
    constexpr explicit right_partial(U && u) : _t{CB_FWD(u)} {}
    template <typename ...U> requires std::regular_invocable<Fn, U..., T>
    [[nodiscard]] constexpr
    auto operator()(U &&... u) const noexcept(noexcept(Fn{}(CB_FWD(u)..., _t))) -> decltype(auto)
    { return Fn{}(CB_FWD(u)..., _t); }
};

template <typename Base>
struct binary_fn
{
    using base = Base;
    using is_transparent = void;

    template <typename T>
    [[nodiscard]] constexpr
    static auto left(T && t) noexcept(noexcept(partial<base, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}))
    { return partial<base, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}; }

    template <typename T>
    [[nodiscard]] constexpr
    static auto right(T && t) noexcept(noexcept(right_partial<base, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}))
    { return right_partial<base, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}; }

    template <typename T>
    [[nodiscard]] constexpr CB_STATIC
    auto operator()(T && t) CB_CONST noexcept(noexcept(left(CB_FWD(t))))
    { return left(CB_FWD(t)); }
};

template <typename Base>
struct compare_tuple_fn
{
    template <typename Tuple>
        requires (detail::tuple_size<Tuple> > 1)
    [[nodiscard]] constexpr CB_STATIC
    auto operator()(Tuple && p) CB_CONST -> decltype(auto)
    {
        return [p=CB_FWD(p)]<std::size_t ...I>(std::index_sequence<I...>) {
            return (Base{}(CB_FWD_LIKE(p, get<I>(p)), CB_FWD_LIKE(p, get<I + 1>(p))) and ...);
        }(std::make_index_sequence<detail::tuple_size<Tuple> - 1>{});
    }
};

template <typename Base>
struct compare_operator : public binary_fn<Base>
{
    // using binary_fn<Base>::operator();
    using binary_fn<Base>::right;
    template <typename T>
    [[nodiscard]] constexpr CB_STATIC
    auto operator()(T && t) CB_CONST noexcept(noexcept(right(CB_FWD(t))))
    { return right(CB_FWD(t)); }
    [[no_unique_address]] compare_tuple_fn<Base> tuple;
};

template <typename Base>
struct recursive_tuple_fn
{
    using base = Base;

    template <std::size_t I, typename Tuple>
    constexpr static
    auto _impl(Tuple && p) {
        if constexpr (I + 1 < detail::tuple_size<Tuple>) {
            return base{}(CB_FWD_LIKE(p, get<I>(p)), _impl<I + 1>(CB_FWD(p)));
        } else {
            return CB_FWD_LIKE(p, get<I>(p));
        }
    }

    template <typename Tuple>
        requires (detail::tuple_size<Tuple> > 0)
    [[nodiscard]]
    constexpr CB_STATIC
    auto operator()(Tuple && p) CB_CONST -> decltype(auto)
    {
        return _impl<0>(CB_FWD(p));
    }
};

template <typename Base>
struct arithmetic_operator : public binary_fn<Base>
{
    using binary_fn<Base>::operator();
    [[no_unique_address]] recursive_tuple_fn<Base> tuple;
};

#undef CB_FWD_LIKE
#undef CB_FWD
} // namespace callables

#endif /* CB_DETAIL_PARTIAL_HPP */
