/**
 * @author      : rbrugo (brugo.riccardo@gmail.com)
 * @created     : Thursday Dec 04, 2025 23:38:08 CET
 * @description : experimental nullable traits and nullable concept implementation
 * @license     :
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * */

#ifndef CB_NULLABLE_HPP
#define CB_NULLABLE_HPP

// TODO: should replace with a concept + overload approach as in functor?

#include <optional>

#include "detail/_config_begin.hpp"
namespace callables
{
// constexpr inline struct null_t {} null;

// Mechanism 1: nullable_traits
template <typename T>
struct nullable_traits
{
    using value_type = typename T::value_type;
    /**
     * @brief check whether the parameter is null
     *
     * @param obj the object to be checked
     * @return whether it is null
     */
    static constexpr bool is_null(T const & obj);  // { return obj == null_value; }

    /**
     * @brief returns the content of the passed parameter, assuming it is not null
     *
     * @param obj the object whose value must be returned
     * @return the object's content
     */
    static constexpr auto get_value(T const & obj) -> value_type const &;  // { return *obj; }
    static constexpr auto get_value(T & obj) -> value_type &;  // { return *obj; }
};

template <typename T> struct nullable_traits<T const> : public nullable_traits<T> {};
template <typename T> struct nullable_traits<T &> : public nullable_traits<T> {};
template <typename T> struct nullable_traits<T &&> : public nullable_traits<T> {};

// Mechanism 2: is_null for always null types
template <typename T> constexpr inline auto is_null_type = false;
template <typename T> constexpr inline auto is_null_type<T const> = is_null_type<T>;
template <typename T> constexpr inline auto is_null_type<T &> = is_null_type<T>;
template <typename T> constexpr inline auto is_null_type<T &&> = is_null_type<T>;

// template <> constexpr inline auto is_null_type<null_t> = true;
template <> constexpr inline auto is_null_type<std::nullptr_t> = true;
template <> constexpr inline auto is_null_type<std::nullopt_t> = true;

template <typename T> requires is_null_type<T>
struct nullable_traits<T>
{
    using value_type = std::remove_cvref_t<T>;
    static constexpr bool is_null(T const &) noexcept { return true; }
    static constexpr auto get_value(T const & obj) noexcept -> decltype(auto) { return obj; }
};


// Mechanism 3: has is_null free function or member function
// TODO: should I also implement a getter? No point in implementing `is_null` without getter
// template <typename T>
// constexpr inline auto is_null_free_function = requires(T const & t) { { is_null(t) } -> std::same_as<bool>; };
//
// template <typename T>
// constexpr inline auto is_null_member_function = requires(T const & t) { { t.is_null() } -> std::same_as<bool>; };
//
// template <typename T> requires is_null_free_function<T>
// struct nullable_traits<T>
// {
//     using value_type = T;
//     static constexpr bool is_null(T const & obj) noexcept(noexcept(is_null(obj))) { return is_null(obj); }
// };
//
// template <typename T> requires is_null_member_function<T>
// struct nullable_traits<T>
// {
//     using value_type = T;
//     static constexpr bool is_null(T const & obj) noexcept(noexcept(obj.is_null())) { return obj.is_null(); }
// };

// Implementations
template <typename T>
struct nullable_traits<T *>
{
    using value_type = T;
    static constexpr bool is_null(T * const ptr) noexcept { return ptr == nullptr; }
    static constexpr auto get_value(T * const ptr) noexcept { return *ptr; }
};

template <typename T>
struct nullable_traits<std::optional<T>>
{
    using value_type = std::optional<T>::value_type;
    static constexpr bool is_null(std::optional<T> const & obj) noexcept { return obj == std::nullopt; }
    template <typename U = std::optional<T>>
    static constexpr auto get_value(U && obj) noexcept { return *CB_FWD(obj); }
};

// Concept
template <typename T> concept nullable = requires(T const & t) {
    typename nullable_traits<T>::value_type;
    nullable_traits<T>::is_null;
    { nullable_traits<T>::is_null(t) } -> std::same_as<bool>;
    { nullable_traits<T>::get_value(t) };
};

// static_assert(nullable<std::optional<int>>);
// static_assert(nullable_traits<std::optional<int>>::is_null({}));
// static_assert(std::optional<int>{} == null);

}  // namespace callables

#include "detail/_config_end.hpp"  // IWYU pragma: export
#endif /* CB_NULLABLE_HPP */
