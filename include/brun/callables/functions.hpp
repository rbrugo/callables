/**
 * @author      : Riccardo Brugo (brugo.riccardo@gmail.com)
 * @created     : Sunday Dec 13, 2020 21:54:35 CET
 * @description : implementations of partially-applicable arithmetic functions
 * @license     :
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * */

#ifndef CB_FUNCTIONS_HPP
#define CB_FUNCTIONS_HPP

#include <span>
#include <cstdint>
#include <functional>
#include "identity.hpp"     // IWYU pragma: export
#include "combinators.hpp"  // IWYU pragma: export
#include "nullable.hpp"
#include "detail/partial.hpp"
#include "detail/functional.hpp"

#include "detail/_config_begin.hpp"
#if defined CB_TESTING_ON
#include <string_view>
#endif

namespace callables
{
// apply
// compose         : combinators
// on              : combinators
// construct
// get             :  access   ?
// at              :  access   ?
// from_container  :  access   ?
// addressof
// dereference
// not_
// value_or
// transform_at    :  access   ?

// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ...................................APPLY.................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct apply_fn : public binary_fn<apply_fn>
{
    template <typename Fn, typename Tuple>
        requires detail::direct_applicable<Fn, Tuple>
    constexpr CB_STATIC
    auto operator()(Fn && fn, Tuple && args) CB_CONST
        noexcept(noexcept(apply(CB_FWD(fn), CB_FWD(args))))
        -> decltype(auto)
    { return apply(CB_FWD(fn), CB_FWD(args)); }

    template <typename Fn, typename T>
        requires detail::has_member_apply_with<T, Fn>
    constexpr CB_STATIC
    auto operator()(Fn && fn, T && obj) CB_CONST
        noexcept(noexcept(CB_FWD(obj).apply(CB_FWD(fn))))
        -> decltype(auto)
    { return CB_FWD(obj).apply(CB_FWD(fn)); }

    using binary_fn<apply_fn>::operator();
};

constexpr inline apply_fn apply;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .................................ADDRESSOF.................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct addressof_fn {
    constexpr CB_STATIC
    auto operator()(auto & obj) CB_CONST noexcept -> auto * { return std::addressof(obj); }
    constexpr CB_STATIC
    auto operator()(auto const & obj) CB_CONST noexcept -> auto const * { return std::addressof(obj); }
};

constexpr inline addressof_fn addressof;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ................................DEREFERENCE................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct dereference_fn {
    template <typename T>
        requires requires(T && t) { *CB_FWD(t); }
    constexpr CB_STATIC
    auto operator()(T && obj) CB_CONST noexcept -> decltype(auto)
    { return *CB_FWD(obj); }
};

constexpr inline dereference_fn dereference;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ...................................NOT_FN................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct not_fn
{
    template <typename Fn, typename ...Args>
        requires (std::invocable<Fn, Args...> and sizeof...(Args) >= 1)
    constexpr CB_STATIC auto operator()(Fn && fn, Args &&... args)
    {
        return not CB_FWD(fn)(CB_FWD(args)...);
    }

    template <typename T>
    [[nodiscard]] constexpr
    CB_STATIC auto operator()(T && t) CB_CONST noexcept(noexcept(partial<not_fn, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}))
    { return partial<not_fn, std::unwrap_ref_decay_t<T>>{CB_FWD(t)}; }
};

constexpr inline not_fn not_;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .................................CONSTRUCT.................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
template <typename T>
struct construct_fn
{
private:
    struct from_tuple_fn
    {
        template <typename ...Args>
            requires std::constructible_from<T, Args...>
        constexpr CB_STATIC
        auto operator()(std::tuple<Args...> && args) CB_CONST
            noexcept(std::is_nothrow_constructible_v<T, Args...>)
            -> decltype(auto)
        {
            return [args=std::move(args)]<std::size_t ...I>(std::index_sequence<I...>) {
                return T(std::get<I>(args)...);
            }(std::make_index_sequence<sizeof...(Args)>{});
        }

        template <typename ...Args>
            requires std::constructible_from<T, Args...>
        constexpr CB_STATIC
        auto operator()(std::tuple<Args...> const & args) CB_CONST
            noexcept(std::is_nothrow_constructible_v<T, Args...>)
            -> decltype(auto)
        {
            return [args=std::move(args)]<std::size_t ...I>(std::index_sequence<I...>) {
                return T(std::get<I>(args)...);
            }(std::make_index_sequence<sizeof...(Args)>{});
        }
    };

public:
    [[no_unique_address]] from_tuple_fn from_tuple;

    template <typename ...Args>
        requires std::constructible_from<T, Args...>
    constexpr CB_STATIC
    auto operator()(Args &&... args) CB_CONST
        noexcept(std::is_nothrow_constructible_v<T, Args...>)
        -> decltype(auto)
    { return T(CB_FWD(args)...); }
};

template <typename T>
constexpr inline construct_fn<T> construct;

// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ....................................GET..................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
template <std::size_t N>
struct get_fn
{
    template <typename Obj>
    constexpr CB_STATIC
    auto operator()(Obj && obj) CB_CONST noexcept(noexcept(get<N>(CB_FWD(obj))))
        -> decltype(auto)
    { return get<N>(CB_FWD(obj)); }
};

template <std::size_t N>
constexpr inline get_fn<N> get;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .....................................AT..................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct at_fn
{
    template <typename T, typename ...>
    struct first_ { using type = T; };

    template <typename ...N>
    struct use_member
    {
        using storage_t = std::conditional_t<sizeof...(N) != 1, std::tuple<N...>, typename first_<N...>::type>;
        storage_t indices;

        template <typename Obj>
        constexpr auto operator()(Obj && obj) -> decltype(auto)
        {
            if constexpr (sizeof...(N) == 1) {
                return at_fn{}(CB_FWD(obj), indices);
            } else {
                return std::apply([obj=CB_FWD(obj)](N &&... args) {
                    return at_fn{}(CB_FWD(obj), CB_FWD(args)...);
                }, indices);
            }
        }
    };

#if CB_HAS_MD_SUBSCRIPT == 1
    template <typename ...N>
    struct use_op
    {
        using storage_t = std::conditional_t<sizeof...(N) != 1, std::tuple<N...>, typename first_<N...>::type>;
        storage_t indices;

        template <typename Obj>
        constexpr auto operator()(Obj && obj) -> decltype(auto)
        {
            if constexpr (sizeof...(N) == 1) {
                return at_fn{}[CB_FWD(obj), indices];
            } else {
                return std::apply([obj=CB_FWD(obj)](N &&... args) {
                    return at_fn{}[CB_FWD(obj), CB_FWD(args)...];
                }, indices);
            }
        }
    };
#else
    template <typename N>
    struct use_op
    {
        N index;

        template <typename Obj>
        constexpr auto operator()(Obj && obj) -> decltype(auto)
        {
            return CB_FWD(obj)[index];
        }
    };
#endif


    template <typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator()(N &&... n) CB_CONST noexcept -> decltype(auto)
    { return use_member<std::unwrap_ref_decay_t<N>...>{CB_FWD(n)...}; }

    template <typename Obj, typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator()(Obj && obj, N &&... n) CB_CONST noexcept(noexcept(CB_FWD(obj).at(CB_FWD(n)...)))
        -> decltype(auto)
    { return CB_FWD(obj).at(CB_FWD(n)...); }

#if CB_HAS_MD_SUBSCRIPT == 1
    template <typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator[](N &&... n) CB_CONST noexcept -> decltype(auto)
    { return use_op<std::unwrap_ref_decay_t<N>...>{CB_FWD(n)...}; }

    template <typename Obj, typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator[](Obj && obj, N &&... n) CB_CONST noexcept(noexcept(CB_FWD(obj)[CB_FWD(n)...]))
        -> decltype(auto)
    { return CB_FWD(obj)[CB_FWD(n)...]; }
#else
    template <typename N>
    constexpr CB_STATIC
    auto operator[](N && n) CB_CONST noexcept -> decltype(auto)
    { return use_op<std::unwrap_ref_decay_t<N>>{CB_FWD(n)}; }

    template <typename Obj, typename N>
    constexpr CB_STATIC
    auto operator[](Obj && obj, N && n) CB_CONST noexcept(noexcept(CB_FWD(obj)[CB_FWD(n)]))
        -> decltype(auto)
    { return CB_FWD(obj)[CB_FWD(n)]; }
#endif
};

constexpr inline at_fn at;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ...............................FROM_CONTAINER............................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct from_container_fn
{
    template <std::ranges::range Cont, typename Idx>
    static constexpr
    auto use_iterators(Cont && cont, Idx && idx) -> decltype(auto)
    {
        return *std::ranges::next(
            std::ranges::begin(cont),
            CB_FWD(idx),
            std::ranges::end(cont)
        );
    }

    template <typename Cont, typename Idx>
    requires requires(Cont && c, Idx && i) { CB_FWD(c).at(CB_FWD(i)); }
    static constexpr
    auto use_at(Cont && c, Idx && i) -> decltype(auto) {
        return CB_FWD(c).at(CB_FWD(i));
    }

    template <typename Cont, typename Idx>
    requires requires(Cont && c, Idx && i) { CB_FWD(c)[CB_FWD(i)]; }
    static constexpr
    auto use_op(Cont && c, Idx && i) -> decltype(auto) {
        return CB_FWD(c)[CB_FWD(i)];
    }

    template <typename Cont, typename Idx>
    constexpr CB_STATIC
    auto try_all(Cont && c, Idx && i) CB_CONST -> decltype(auto)
    {
        if constexpr (requires { CB_FWD(c).at(CB_FWD(i)); }) {
            return use_at(CB_FWD(c), CB_FWD(i));
        } else if constexpr (requires { CB_FWD(c)[CB_FWD(i)]; }) {
            return use_op(CB_FWD(c), CB_FWD(i));
        } else if constexpr (std::ranges::range<Cont>) {
            return use_iterators(CB_FWD(c), CB_FWD(i));
        } else {
            static_assert(false, "the container must be indexable via op[], .at or iterators");
        }
    }

    template <typename Cont, typename Idx>
    constexpr CB_STATIC
    auto try_unsafe(Cont && c, Idx && i) CB_CONST -> decltype(auto)
    {
        if constexpr (requires { CB_FWD(c)[CB_FWD(i)]; }) {
            return use_op(CB_FWD(c), CB_FWD(i));
        } else if (std::ranges::range<Cont>) {
            return use_iterators(CB_FWD(c), CB_FWD(i));
        } else {
            static_assert(false, "the container must be indexable via op[] or iterators");
        }
    }

    template <typename Cont, typename Idx>
    constexpr CB_STATIC
    auto operator()(Cont && c, Idx && i) CB_CONST -> decltype(auto)
    {
        return try_all(CB_FWD(c), CB_FWD(i));
    }

    template <typename T>
    constexpr CB_STATIC
    auto operator()(T && t) CB_CONST noexcept
    {
        return partial<from_container_fn, std::unwrap_ref_decay_t<T>>{CB_FWD(t)};
    }

    template <typename T, std::size_t N>
    constexpr CB_STATIC
    auto operator()(T (&t)[N]) CB_CONST noexcept
    {
        return partial<from_container_fn, std::span<T>>{std::span<T>{t, N}};
    }
};

constexpr inline from_container_fn from_container;




// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ..................................VALUE_OR.................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct value_or_fn
{
    template <nullable Opt, typename T>
    requires requires(Opt opt, T t) {
        { callables::nullable_traits<Opt>::get_value(opt) } -> std::convertible_to<T>;
    }
    constexpr CB_STATIC
    auto operator()(Opt && opt, T && t) CB_CONST noexcept
        -> std::remove_cvref_t<decltype(*opt)>
    {
        using traits = callables::nullable_traits<Opt>;
        if (traits::is_null(opt)) {
            return traits::get_value(CB_FWD(opt));
        }
        return CB_FWD(t);
    }

    template <typename Null, typename T>
    requires is_null_type<Null>
    constexpr CB_STATIC
    auto operator()(Null &&, T && t) CB_CONST noexcept -> decltype(auto) { return CB_FWD(t); }

    template <typename T>
    constexpr CB_STATIC
    auto operator()(T && t) CB_CONST noexcept
    {
        return right_partial<value_or_fn, std::unwrap_ref_decay_t<T>>{CB_FWD(t)};
    }
};

constexpr inline value_or_fn value_or;

static_assert(value_or(nullptr, 10) == 10);


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ................................TRANSFORM_AT................................ //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
template <std::int64_t N>
struct transform_at_fn
{

    template <typename Fn>
    struct capture
    {
        [[no_unique_address]] Fn _fn;

        template <typename T, std::int64_t I>
        constexpr auto _maybe_apply(T && t) -> decltype(auto)
        {
            if constexpr (I == N) {
                return CB_FWD(_fn)(CB_FWD(t));
            } else {
                return CB_FWD(t);
            }
        }

        template <typename T> static constexpr auto ref(T & t) { return std::ref(t); }
        template <typename T> static constexpr auto ref(T const & t) { return std::cref(t); }
        template <typename T> static constexpr auto ref(T && t) { return t; }
        template <typename T> static constexpr auto ref(T const && t) { return t; }

        template <typename T, std::int64_t I>
        constexpr auto apply(T && t) -> decltype(auto)
        { return ref(_maybe_apply<T, I>(CB_FWD(t))); }


        template <typename Tuple>
            requires std::invocable<Fn, std::tuple_element_t<N, Tuple>>
        constexpr auto operator()(Tuple && tuple) -> decltype(auto)
        {
            return [tp=CB_FWD(tuple),this]<std::size_t ...I>(std::index_sequence<I...>) mutable {
                return std::make_tuple(
                    this->apply<std::tuple_element_t<I, Tuple>, I>(std::forward_like<Tuple>(std::get<I>(tp)))...
                );
            }(std::make_index_sequence<std::tuple_size_v<std::remove_cvref_t<Tuple>>>());
        }
    };

    template <typename Fn>
    constexpr CB_STATIC auto operator()(Fn && fn) CB_CONST noexcept
    {
        return capture<Fn>(CB_FWD(fn));
    }
};

template <std::int64_t N>
constexpr inline auto transform_at = transform_at_fn<N>{};

#if defined CB_TESTING_TRANSFORM_AT
static_assert(transform_at<1>([](auto x) { return x * 2; })(std::tuple{0, 10}) == std::tuple{0, 20});
static_assert(transform_at<0>([](auto  ) { return 'a'; })(std::tuple{0, 10}) == std::tuple{'a', 10});
#endif

} // namespace callables

#include "detail/_config_end.hpp"  // IWYU pragma: export
#endif /* CB_FUNCTIONS_HPP */
