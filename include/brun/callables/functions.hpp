/**
 * @author      : Riccardo Brugo (brugo.riccardo@gmail.com)
 * @created     : Sunday Dec 13, 2020 21:54:35 CET
 * @description : implementations of partially-applicable arithmetic functions
 * @license     :
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * */

#ifndef CB_FUNCTIONS_HPP
#define CB_FUNCTIONS_HPP

#if defined(__cpp_multidimensional_subscript) && __cpp_multidimensional_subscript >= 202110L
#define CB_HAS_MD_SUBSCRIPT 1
#else
#define CB_HAS_MD_SUBSCRIPT 0
#endif

#include <span>
#include <cstdint>
#include <functional>
#include "identity.hpp"  // IWYU pragma: export
#include "nullable.hpp"
#include "detail/partial.hpp"
#include "detail/functional.hpp"

#if defined CB_TESTING_ON
#include <string_view>
#endif

namespace callables
{
#define CB_FWD(x) static_cast<decltype(x) &&>(x)

// apply
// compose
// on
// construct
// get  :  access
// at  :  access
// from_container  :  access
// addressof
// dereference
// value_or
// transform_at  :  access

// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ...................................APPLY.................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct apply_fn : public binary_fn<apply_fn>
{
    template <typename Fn, typename Tuple>
        requires detail::direct_applicable<Fn, Tuple>
    constexpr CB_STATIC
    auto operator()(Fn && fn, Tuple && args) CB_CONST
        noexcept(noexcept(apply(CB_FWD(fn), CB_FWD(args))))
        -> decltype(auto)
    { return apply(CB_FWD(fn), CB_FWD(args)); }

    template <typename Fn, typename T>
        requires detail::has_member_apply_with<T, Fn>
    constexpr CB_STATIC
    auto operator()(Fn && fn, T && obj) CB_CONST
        noexcept(noexcept(CB_FWD(obj).apply(CB_FWD(fn))))
        -> decltype(auto)
    { return CB_FWD(obj).apply(CB_FWD(fn)); }

    using binary_fn<apply_fn>::operator();
};

constexpr inline apply_fn apply;

// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ..................................COMPOSE................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct compose_fn
{
    template <typename ...Fns>
    struct compose_fn_capture
    {
    private:
        std::tuple<Fns...> _fns;

        struct uncallable {};

        template <typename ...Args>
        constexpr
        static auto call_with_args(std::tuple<Fns...> & tp, Args &&... args) -> decltype(auto)
        { return _call_impl<0>(tp, CB_FWD(args)...); }

        template <typename ...Args>
        constexpr
        static auto call_with_args(std::tuple<Fns...> const & tp, Args &&... args) -> decltype(auto)
        { return _call_impl<0>(tp, CB_FWD(args)...); }

        template <std::size_t I, typename Tuple, typename ...Args>
        constexpr
        static auto _call_impl(Tuple && fns, Args &&... args) -> decltype(auto)
        {
#           define GET(idx, tpl) std::get<idx>(CB_FWD(tpl))
            if constexpr (I == sizeof...(Fns) - 1) {
                if constexpr (std::invocable<std::tuple_element_t<I, std::remove_cvref_t<Tuple>>, Args...>) {
                    return GET(I, fns)(CB_FWD(args)...);
                } else if constexpr (sizeof...(Fns) != 1) {
                    return uncallable{};
                }
            } else {
                using nested_call_result = decltype(_call_impl<I + 1>(CB_FWD(fns), CB_FWD(args)...));
                if constexpr (not std::same_as<nested_call_result, uncallable>) {
                    return GET(I, fns)(_call_impl<I + 1>(CB_FWD(fns), CB_FWD(args)...));
                } else {
                    using fn_t = std::tuple_element_t<I, std::remove_cvref_t<Tuple>>;
                    if constexpr ((std::invocable<fn_t, decltype(_call_impl<I + 1>(CB_FWD(fns), CB_FWD(args)))...>)) {
                        return GET(I, fns)(_call_impl<I + 1>(CB_FWD(fns),CB_FWD(args))...);
                    } else if constexpr (I != 0) {
                        return uncallable{};
                    }
                }
            }
#           undef GET
        }
    public:
        template <typename ...Fns2>
            requires detail::pairwise_constructible<Fns...>::template from<Fns2...>
        constexpr
        compose_fn_capture(Fns2 &&... fns) : _fns{CB_FWD(fns)...} {}

        template <typename ...Args>
        constexpr auto operator()(Args &&... args) const -> decltype(auto)
        { return call_with_args(_fns, CB_FWD(args)...); }

        template <typename ...Args>
        constexpr auto operator()(Args &&... args) -> decltype(auto)
        { return call_with_args(_fns, CB_FWD(args)...); }
    };

    template <typename ...Fns>
    constexpr CB_STATIC
    auto operator()(Fns &&... fns) CB_CONST noexcept
    {
        return compose_fn_capture<Fns...>{CB_FWD(fns)...};
    }
};

constexpr inline compose_fn compose;

#if defined CB_TESTING_COMPOSE
static_assert(compose([](auto x) { return x + 1; }, [](auto a, auto b) { return a + b; })(0, 2) == 3);
static_assert(compose([](auto c) { return c - 'z'; }, [](auto c) { return c + 'z'; })('c') == 'c');
static_assert(compose(+[](int a, int b) { return a + b; }, +[](int x) { return x; })(0, 0) == 0);
#endif


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .....................................ON..................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct on_fn
{
    template <typename UnaryFn, typename BinaryFn>
    struct inner : public binary_fn<inner<UnaryFn, BinaryFn>>, applicable_on_tuples<inner<UnaryFn, BinaryFn>>
    {
        [[no_unique_address]] UnaryFn _un;
        [[no_unique_address]] BinaryFn _bin;

        template <typename T, typename U>
            requires requires(T && t, U && u) {
                { _un(t) };
                { _un(u) };
                { _bin(_un(t), _un(u)) };
            }
        [[nodiscard]] constexpr auto operator()(T && t, U && u) const -> decltype(auto)
        {
            return _bin(_un(CB_FWD(t)), _un(CB_FWD(u)));
        }

        using inner::binary_fn::operator();
    };

    template <typename UnaryFn>
    struct outer
    {
        [[no_unique_address]] UnaryFn _un;

        template <typename BinaryFn>
        [[nodiscard]] constexpr auto operator()(BinaryFn && binary) const & -> decltype(auto)
        {
            return inner<UnaryFn, std::remove_cvref_t<BinaryFn>>{{}, _un, CB_FWD(binary)};
        }

        template <typename BinaryFn>
        [[nodiscard]] constexpr auto operator()(BinaryFn && binary) && -> decltype(auto)
        {
            return inner<UnaryFn, std::remove_cvref_t<BinaryFn>>{
                {}, {}, std::move(_un), CB_FWD(binary)
            };
        }
    };

    template <typename UnaryFn>
    [[nodiscard]] constexpr static auto operator()(UnaryFn && fn) noexcept
    { return outer<std::remove_cvref_t<UnaryFn>>{CB_FWD(fn)}; }

    template <typename UnaryFn, typename BinaryFn>
    [[nodiscard]] constexpr static auto operator()(UnaryFn && unary, BinaryFn && binary) noexcept
    {
        return inner<std::remove_cvref_t<UnaryFn>, std::remove_cvref_t<BinaryFn>>{
            {}, {}, CB_FWD(unary), CB_FWD(binary)
        };
    }
};

constexpr inline on_fn on;

#if defined CB_TESTING_ON
namespace _test
{
constexpr inline auto mod = [](auto const & x) static { return x % 2; };
constexpr inline auto eq = [](auto const & a, auto const & b) static { return a == b; };
constexpr inline auto ne = [](auto const & a, auto const & b) static { return a != b; };
constexpr inline auto len = [](auto const & x) static { return size(x); };
constexpr inline auto gt = [](auto const & a, auto const & b) static { return a > b; };
constexpr inline auto lt = [](auto const & a, auto const & b) static { return a < b; };

using std::string_view_literals::operator""sv;

static_assert(on(mod, eq)(0, 2));
static_assert(on(mod, ne)(0, 3));
static_assert(on(mod, eq)(0)(2));
static_assert(on(len)(eq)("ciao"sv)("hola"sv));
static_assert(on(len)(eq)("ciao"sv)("hola"sv));
static_assert(on(len)(lt).left("ciao"sv)("hello"sv));
static_assert(on(len)(gt).right("ciao"sv)("hello"sv));
}  // namespace _test
#endif


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .................................ADDRESSOF.................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct addressof_fn {
    constexpr CB_STATIC
    auto operator()(auto & obj) CB_CONST noexcept -> auto * { return std::addressof(obj); }
    constexpr CB_STATIC
    auto operator()(auto const & obj) CB_CONST noexcept -> auto const * { return std::addressof(obj); }
};

constexpr inline addressof_fn addressof;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ................................DEREFERENCE................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct dereference_fn {
    template <typename T>
        requires requires(T && t) { *CB_FWD(t); }
    constexpr CB_STATIC
    auto operator()(T && obj) CB_CONST noexcept -> decltype(auto)
    { return *CB_FWD(obj); }
};

constexpr inline dereference_fn dereference;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .................................CONSTRUCT.................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
template <typename T>
struct construct_fn
{
private:
    struct from_tuple_fn
    {
        template <typename ...Args>
            requires std::constructible_from<T, Args...>
        constexpr CB_STATIC
        auto operator()(std::tuple<Args...> && args) CB_CONST
            noexcept(std::is_nothrow_constructible_v<T, Args...>)
            -> decltype(auto)
        {
            return [args=std::move(args)]<std::size_t ...I>(std::index_sequence<I...>) {
                return T(std::get<I>(args)...);
            }(std::make_index_sequence<sizeof...(Args)>{});
        }

        template <typename ...Args>
            requires std::constructible_from<T, Args...>
        constexpr CB_STATIC
        auto operator()(std::tuple<Args...> const & args) CB_CONST
            noexcept(std::is_nothrow_constructible_v<T, Args...>)
            -> decltype(auto)
        {
            return [args=std::move(args)]<std::size_t ...I>(std::index_sequence<I...>) {
                return T(std::get<I>(args)...);
            }(std::make_index_sequence<sizeof...(Args)>{});
        }
    };

public:
    [[no_unique_address]] from_tuple_fn from_tuple;

    template <typename ...Args>
        requires std::constructible_from<T, Args...>
    constexpr CB_STATIC
    auto operator()(Args &&... args) CB_CONST
        noexcept(std::is_nothrow_constructible_v<T, Args...>)
        -> decltype(auto)
    { return T(CB_FWD(args)...); }
};

template <typename T>
constexpr inline construct_fn<T> construct;

// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ....................................GET..................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
template <std::size_t N>
struct get_fn
{
    template <typename Obj>
    constexpr CB_STATIC
    auto operator()(Obj && obj) CB_CONST noexcept(noexcept(get<N>(CB_FWD(obj))))
        -> decltype(auto)
    { return get<N>(CB_FWD(obj)); }
};

template <std::size_t N>
constexpr inline get_fn<N> get;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// .....................................AT..................................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct at_fn
{
    template <typename T, typename ...>
    struct first_ { using type = T; };

    template <typename ...N>
    struct use_member
    {
        using storage_t = std::conditional_t<sizeof...(N) != 1, std::tuple<N...>, typename first_<N...>::type>;
        storage_t indices;

        template <typename Obj>
        constexpr auto operator()(Obj && obj) -> decltype(auto)
        {
            if constexpr (sizeof...(N) == 1) {
                return at_fn{}(CB_FWD(obj), indices);
            } else {
                return std::apply([obj=CB_FWD(obj)](N &&... args) {
                    return at_fn{}(CB_FWD(obj), CB_FWD(args)...);
                }, indices);
            }
        }
    };

#if CB_HAS_MD_SUBSCRIPT
    template <typename ...N>
    struct use_op
    {
        using storage_t = std::conditional_t<sizeof...(N) != 1, std::tuple<N...>, typename first_<N...>::type>;
        storage_t indices;

        template <typename Obj>
        constexpr auto operator()(Obj && obj) -> decltype(auto)
        {
            if constexpr (sizeof...(N) == 1) {
                return at_fn{}[CB_FWD(obj), indices];
            } else {
                return std::apply([obj=CB_FWD(obj)](N &&... args) {
                    return at_fn{}[CB_FWD(obj), CB_FWD(args)...];
                }, indices);
            }
        }
    };
#else
    template <typename N>
    struct use_op
    {
        N index;

        template <typename Obj>
        constexpr auto operator()(Obj && obj) -> decltype(auto)
        {
            return CB_FWD(obj)[index];
        }
    };
#endif


    template <typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator()(N &&... n) CB_CONST noexcept -> decltype(auto)
    { return use_member<std::unwrap_ref_decay_t<N>...>{CB_FWD(n)...}; }

    template <typename Obj, typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator()(Obj && obj, N &&... n) CB_CONST noexcept(noexcept(CB_FWD(obj).at(CB_FWD(n)...)))
        -> decltype(auto)
    { return CB_FWD(obj).at(CB_FWD(n)...); }

#if CB_HAS_MD_SUBSCRIPT
    template <typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator[](N &&... n) CB_CONST noexcept -> decltype(auto)
    { return use_op<std::unwrap_ref_decay_t<N>...>{CB_FWD(n)...}; }

    template <typename Obj, typename ...N>
        requires (sizeof...(N) > 0)
    constexpr CB_STATIC
    auto operator[](Obj && obj, N &&... n) CB_CONST noexcept(noexcept(CB_FWD(obj)[CB_FWD(n)...]))
        -> decltype(auto)
    { return CB_FWD(obj)[CB_FWD(n)...]; }
#else
    template <typename N>
    constexpr CB_STATIC
    auto operator[](N && n) CB_CONST noexcept -> decltype(auto)
    { return use_op<std::unwrap_ref_decay_t<N>>{CB_FWD(n)}; }

    template <typename Obj, typename N>
    constexpr CB_STATIC
    auto operator[](Obj && obj, N && n) CB_CONST noexcept(noexcept(CB_FWD(obj)[CB_FWD(n)]))
        -> decltype(auto)
    { return CB_FWD(obj)[CB_FWD(n)]; }
#endif
};

constexpr inline at_fn at;


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ...............................FROM_CONTAINER............................... //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct from_container_fn
{
    template <std::ranges::range Cont, typename Idx>
    static constexpr
    auto use_iterators(Cont && cont, Idx && idx) -> decltype(auto)
    {
        return *std::ranges::next(
            std::ranges::begin(cont),
            CB_FWD(idx),
            std::ranges::end(cont)
        );
    }

    template <typename Cont, typename Idx>
    requires requires(Cont && c, Idx && i) { CB_FWD(c).at(CB_FWD(i)); }
    static constexpr
    auto use_at(Cont && c, Idx && i) -> decltype(auto) {
        return CB_FWD(c).at(CB_FWD(i));
    }

    template <typename Cont, typename Idx>
    requires requires(Cont && c, Idx && i) { CB_FWD(c)[CB_FWD(i)]; }
    static constexpr
    auto use_op(Cont && c, Idx && i) -> decltype(auto) {
        return CB_FWD(c)[CB_FWD(i)];
    }

    template <typename Cont, typename Idx>
    constexpr CB_STATIC
    auto try_all(Cont && c, Idx && i) CB_CONST -> decltype(auto)
    {
        if constexpr (requires { CB_FWD(c).at(CB_FWD(i)); }) {
            return use_at(CB_FWD(c), CB_FWD(i));
        } else if constexpr (requires { CB_FWD(c)[CB_FWD(i)]; }) {
            return use_op(CB_FWD(c), CB_FWD(i));
        } else if (std::ranges::range<Cont>) {
            return use_iterators(CB_FWD(c), CB_FWD(i));
        } else {
            static_assert(false, "the container must be indexable via op[], .at or iterators");
        }
    }

    template <typename Cont, typename Idx>
    constexpr CB_STATIC
    auto try_unsafe(Cont && c, Idx && i) CB_CONST -> decltype(auto)
    {
        if constexpr (requires { CB_FWD(c)[CB_FWD(i)]; }) {
            return use_op(CB_FWD(c), CB_FWD(i));
        } else if (std::ranges::range<Cont>) {
            return use_iterators(CB_FWD(c), CB_FWD(i));
        } else {
            static_assert(false, "the container must be indexable via op[] or iterators");
        }
    }

    template <typename Cont, typename Idx>
    constexpr CB_STATIC
    auto operator()(Cont && c, Idx && i) CB_CONST -> decltype(auto)
    {
        return try_all(CB_FWD(c), CB_FWD(i));
    }

    template <typename T>
    constexpr CB_STATIC
    auto operator()(T && t) CB_CONST noexcept
    {
        return partial<from_container_fn, std::unwrap_ref_decay_t<T>>{CB_FWD(t)};
    }

    template <typename T, std::size_t N>
    constexpr CB_STATIC
    auto operator()(T (&t)[N]) CB_CONST noexcept
    {
        return partial<from_container_fn, std::span<T>>{std::span<T>{t, N}};
    }
};

constexpr inline from_container_fn from_container;




// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ..................................VALUE_OR.................................. //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
struct value_or_fn
{
    template <nullable Opt, typename T>
    requires requires(Opt opt, T t) {
        { callables::nullable_traits<Opt>::get_value(opt) } -> std::convertible_to<T>;
    }
    constexpr CB_STATIC
    auto operator()(Opt && opt, T && t) CB_CONST noexcept
        -> std::remove_cvref_t<decltype(*opt)>
    {
        using traits = callables::nullable_traits<Opt>;
        if (traits::is_null(opt)) {
            return traits::get_value(CB_FWD(opt));
        }
        return CB_FWD(t);
    }

    template <typename Null, typename T>
    requires is_null_type<Null>
    constexpr CB_STATIC
    auto operator()(Null &&, T && t) CB_CONST noexcept -> decltype(auto) { return CB_FWD(t); }

    template <typename T>
    constexpr CB_STATIC
    auto operator()(T && t) CB_CONST noexcept
    {
        return right_partial<value_or_fn, std::unwrap_ref_decay_t<T>>{CB_FWD(t)};
    }
};

constexpr inline value_or_fn value_or;

static_assert(value_or(nullptr, 10) == 10);


// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
// ................................TRANSFORM_AT................................ //
// ....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.... //
template <std::int64_t N>
struct transform_at_fn
{

    template <typename Fn>
    struct capture
    {
        [[no_unique_address]] Fn _fn;

        template <typename T, std::int64_t I>
        constexpr auto _maybe_apply(T && t) -> decltype(auto)
        {
            if constexpr (I == N) {
                return CB_FWD(_fn)(CB_FWD(t));
            } else {
                return CB_FWD(t);
            }
        }

        template <typename T> static constexpr auto ref(T & t) { return std::ref(t); }
        template <typename T> static constexpr auto ref(T const & t) { return std::cref(t); }
        template <typename T> static constexpr auto ref(T && t) { return t; }
        template <typename T> static constexpr auto ref(T const && t) { return t; }

        template <typename T, std::int64_t I>
        constexpr auto apply(T && t) -> decltype(auto)
        { return ref(_maybe_apply<T, I>(CB_FWD(t))); }


        template <typename Tuple>
            requires std::invocable<Fn, std::tuple_element_t<N, Tuple>>
        constexpr auto operator()(Tuple && tuple) -> decltype(auto)
        {
            return [tp=CB_FWD(tuple),this]<std::size_t ...I>(std::index_sequence<I...>) mutable {
                return std::make_tuple(
                    this->apply<std::tuple_element_t<I, Tuple>, I>(std::forward_like<Tuple>(std::get<I>(tp)))...
                );
            }(std::make_index_sequence<std::tuple_size_v<std::remove_cvref_t<Tuple>>>());
        }
    };

    template <typename Fn>
    constexpr CB_STATIC auto operator()(Fn && fn) CB_CONST noexcept
    {
        return capture<Fn>(CB_FWD(fn));
    }
};

template <std::int64_t N>
constexpr inline auto transform_at = transform_at_fn<N>{};

#if defined CB_TESTING_TRANSFORM_AT
static_assert(transform_at<1>([](auto x) { return x * 2; })(std::tuple{0, 10}) == std::tuple{0, 20});
static_assert(transform_at<0>([](auto  ) { return 'a'; })(std::tuple{0, 10}) == std::tuple{'a', 10});
#endif

#undef CB_FWD
} // namespace callables

#endif /* CB_FUNCTIONS_HPP */
